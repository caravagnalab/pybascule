---
title: "SigPhylo"
author: "Azad Sadr"
date: "2/10/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(reticulate)
library(stringr)
library(reshape2)
library(ggplot2)
library(ggthemes)
library(dplyr)
library(rjson)
```


```{python libraries, include=FALSE}
import numpy as np
import pandas as pd
import json
```


```{python environment, include=FALSE}
# setup conda environment
#use_condaenv("SigPhylo")
```


```{python data, echo=FALSE}

#-------------------------------------------------------------------------------
# Load json file using python
#-------------------------------------------------------------------------------
json_path = "/home/azad/Documents/thesis/SigPhylo/data/results/output3/output.json"
with open(json_path, "r") as f:
  data = json.load(f)

```


```{r, echo=FALSE}

#-------------------------------------------------------------------------------
# Load full Data-set (OK)
#-------------------------------------------------------------------------------
load_data <- function(json_path) {
  # Load from json file
  data <- fromJSON(file=json_path)  # list
  
  # initialize empty tibble
  data_tibble <- tibble(
    K_Denovo = numeric(), 
    Lambda = numeric(), 
    Log_Like = list(), 
    BIC = list(), 
    Cosine = list(), 
    Alpha = list(), 
    Beta = list(), 
    M_Rec = list()
    )
  
  # mutation feature labels
  features <- data[["input"]][["mutation_features"]] # character
  
  # get initial values from loaded data-set
  for (row in data[["output"]]) {
    
    k_denovo <- row[["k_denovo"]]  # numeric
    lambda <- row[["lambda"]]      # numeric
    
    log_like <- list(row[["likelihoods"]])    # numeric -> list
    bic <- list(row[["BIC"]])                 # numeric -> list
    cosine <- list(row[["cosine"]])           # numeric -> list
    
    alpha <- row[["alpha"]]   # list
    beta <- row[["beta"]]     # list
    m_rec <- row[["M_r"]]     # list
    
    #-------------- alpha ------------------------------------------------------
    alpha_df <- as.data.frame(do.call(rbind, alpha))
    alpha_n <-nrow(alpha_df)
    alpha_k <- ncol(alpha_df)
    rownames(alpha_df) <- paste(c("Branch"), 1:alpha_n, sep = "")
    colnames(alpha_df) <- paste(c("Signature"), 1:alpha_k, sep = "")
    alpha_list <- list(alpha_df)
    
    #-------------- beta -------------------------------------------------------
    beta_df <- as.data.frame(do.call(rbind, beta))
    beta_n <-nrow(beta_df)
    beta_k <- ncol(beta_df)
    rownames(beta_df) <- paste(c("Signature"), 1:beta_n, sep = "")
    colnames(beta_df) <- features
    beta_list <- list(beta_df)
    
    #-------------- phylogeny reconstructed ------------------------------------
    m_rec_df <- as.data.frame(do.call(rbind, m_rec))
    m_rec_n <-nrow(m_rec_df)
    m_rec_k <- ncol(m_rec_df)
    rownames(m_rec_df) <- paste(c("Branch"), 1:m_rec_n, sep = "")
    colnames(m_rec_df) <- features
    m_rec_list <- list(m_rec_df)
    
    # add each run to a row in tibble
    data_tibble <- add_row(data_tibble, 
                           K_Denovo = k_denovo, 
                           Lambda = lambda, 
                           Log_Like = log_like, 
                           BIC = bic, 
                           Cosine = cosine, 
                           Alpha = alpha_list, 
                           Beta = beta_list, 
                           M_Rec = m_rec_list
                           )
  }
  return(data_tibble)
}

```


```{r, echo=FALSE}

#-------------------------------------------------------------------------------
# return best run info (highest log-likelihood) (OK)
#-------------------------------------------------------------------------------
best_loglike <- function(data_tibble) {
  log_like_list <- c()
  for (i in 1:nrow(data_tibble)) {
    log_like <- data_tibble[["Log_Like"]][[i]]
    log_like_list[length(log_like_list)+1] <- log_like[which.max(log_like)]
  }
  
  index <- which.max(log_like_list)
  k <- data_tibble[index, ][["K_Denovo"]]
  lambda <- data_tibble[index, ][["Lambda"]]
  
  return(list("index"=index, 
              "k"=k, 
              "lambda"=lambda))
}

#-------------------------------------------------------------------------------
# return best run info (lowest BIC) (OK)
#-------------------------------------------------------------------------------
best_bic <- function(data_tibble) {
  bic_list <- c()
  for (i in 1:nrow(data_tibble)) {
    bic <- data_tibble[["BIC"]][[i]]
    bic_list[length(bic_list)+1] <- bic[which.max(bic)]
  }
  
  index <- which.max(bic_list)
  k <- data_tibble[index, ][["K_Denovo"]]
  lambda <- data_tibble[index, ][["Lambda"]]
  
  return(list("index"=index, 
              "k"=k, 
              "lambda"=lambda))
}

```


```{r, echo=FALSE}

#-------------------------------------------------------------------------------
# return a tibble includes k_denovo, lambda and likelihood columns (OK)
#-------------------------------------------------------------------------------
k_loglike_lambda <- function(data_tibble) {
  
  t <- tibble(K_Denovo=numeric(), Lambda=numeric(), Log_Like=numeric())
  
  for (i in 1:nrow(data_tibble)) {
    row <- data_tibble[i,]
    
    k_denovo <- row[["K_Denovo"]]  # numeric
    lambda <- row[["Lambda"]]      # numeric
    loglike <- row[["Log_Like"]][[1]]
    loglike_max <- loglike[which.max(loglike)]       # numeric
    
    t <- t %>% add_row(K_Denovo=k_denovo, Lambda=lambda, Log_Like=loglike_max)
  }
  return(t)
}


#-------------------------------------------------------------------------------
# return a tibble includes k_denovo, lambda and BIC columns (OK)
#-------------------------------------------------------------------------------
k_bic_lambda <- function(data_tibble) {
  
  t <- tibble(K_Denovo=numeric(), Lambda=numeric(), BIC=numeric())
  
  for (i in 1:nrow(data_tibble)) {
    row <- data_tibble[i,]
    
    k_denovo <- row[["K_Denovo"]]  # numeric
    lambda <- row[["Lambda"]]      # numeric
    bic <- row[["BIC"]][[1]]
    bic_max <- bic[which.max(bic)]       # numeric
    
    t <- t %>% add_row(K_Denovo=k_denovo, Lambda=lambda, BIC=bic_max)
  }
  return(t)
}

```


```{r, echo=FALSE}

#-------------------------------------------------------------------------------
# plot k vs. likelihood grouped by lambda
#-------------------------------------------------------------------------------
plot_overall_loglike <- function(data) {
  t <- k_loglike_lambda(data)
  ggplot(data = t, aes(x=K_Denovo, y=Log_Like)) + 
    geom_line() + 
    facet_wrap(~Lambda, labeller = label_both) + 
    #theme_fivethirtyeight() + 
    xlab("No. of Infered Signatures") + 
    ylab("Likelihood") + 
    ggtitle("Model Performance over Lambdas Values")
}

#-------------------------------------------------------------------------------
# plot k vs. BIC grouped by lambda
#-------------------------------------------------------------------------------
plot_overall_bic <- function(data) {
  t <- k_bic_lambda(data)
  ggplot(data = t, aes(x=K_Denovo, y=BIC)) + 
    geom_line() + 
    facet_wrap(~Lambda, labeller = label_both) + 
    #theme_fivethirtyeight() + 
    xlab("No. of Infered Signatures") + 
    ylab("BIC") + 
    ggtitle("Model Performance over Lambdas Values")
}

```


```{r, echo=FALSE}

#-------------------------------------------------------------------------------
# plot signature shares over branches for given k grouped by lambda
#-------------------------------------------------------------------------------
plot_alpha <- function(data_tibble, k) {
  
  sig_share <- data_tibble %>% filter(K_Denovo==k) %>% select(Alpha, Lambda)
  
  exposure <- tibble()
  for (i in 1:nrow(sig_share)) {
    row <- sig_share[i,]
    alpha <- row[["Alpha"]][[1]]  # data.frame
    lambda <- row[["Lambda"]]     # numeric
    lambda_list <- rep(lambda, nrow(alpha)) # numeric
    df <- tibble(cbind(alpha, Branch=rownames(alpha), Lambda=lambda_list))
    exposure <- exposure %>% rbind(df)
  }
  
  exposure_long <- exposure %>% melt(id.vars=c("Branch", "Lambda"), 
                                     variable.name=c("Signature"), 
                                     value.name = c("Exposure"))
  
  ggplot(data = exposure_long, aes(x=Branch, y=Exposure, fill=Signature)) + 
    geom_bar(stat = "identity") + 
    facet_wrap(~Lambda, labeller = label_both) + 
    theme_minimal() + 
    ggtitle(paste("No. of Infered Signature:", k))
}

#-------------------------------------------------------------------------------
# plot signature shares over branches for best k grouped by lambda (log-likelihood)
#-------------------------------------------------------------------------------
plot_alpha_loglike <- function(data_tibble) {
  k <- best_loglike(data_tibble)[["k"]]
  plot_alpha(data_tibble, k)
}

#-------------------------------------------------------------------------------
# plot signature shares over branches for best k grouped by lambda (BIC)
#-------------------------------------------------------------------------------
plot_alpha_bic <- function(data_tibble) {
  k <- best_bic(data_tibble)[["k"]]
  plot_alpha(data_tibble, k)
}

```


```{r plot-exposure, warning=FALSE, echo=FALSE}

#-------------------------------------------------------------------------------
# plot inferred signature profiles
#-------------------------------------------------------------------------------
plot_signatures <- function(data_tibble) {
  info <- best_loglike(data_tibble)
  k <- info[["k"]]
  landa <- info[["lambda"]]
  
  df <- data_tibble %>% filter(K_Denovo==k & Lambda==landa)
  beta <- df[["Beta"]][[1]]
  
  x <- as_tibble(cbind(Feats = names(beta), t(beta)))
  x$Signature1 <- as.numeric(x$Signature1)
  x$Signature2 <- as.numeric(x$Signature2)
  
  short_feats_list <- c("C>A", "C>G", "C>T", "T>A", "T>C", "T>G")
  long_feats <- x$Feats
  short_feats <- long_feats
  for (feat in short_feats_list) {
    ind <- str_detect(short_feats, feat)
    short_feats[ind] <- feat
  }
  
  x$Short_Feats <- short_feats
  
  y <- melt(x, 
            id.vars = c("Feats", "Short_Feats"), 
            variable.name = c("Signature"), 
            value.name = c("Probability"))
  
  ggplot(data = y, aes(x=Feats, y=Probability)) + 
    geom_bar(stat = "identity") + 
    facet_wrap(~Signature, ncol = 1) + 
    theme(axis.ticks.x = element_blank(), 
          axis.text.x = element_blank())
    #facet_grid(. ~Short_Feats, scales = "free")
}

#-------------------------------------------------------------------------------
# plot signature profiles from CSV file
#-------------------------------------------------------------------------------
plot_signatures_csv <- function(path) {
  df <- read.table(path, sep = ",", 
                   header = TRUE, 
                   stringsAsFactors = TRUE, 
                   check.names=FALSE)
  return(df)
}

```


# Implementation

### Load full Dataset
```{r, echo=FALSE}
json_path = "/home/azad/Documents/thesis/SigPhylo/data/results/output3/output.json"
data <- load_data(json_path)
data
```


### Best k_denovo and $\lambda$ (based on Likelihood)
```{r, echo=FALSE}

info_loglike <- best_loglike(data)
index_loglike <- info_loglike[["index"]]
k_loglike <- info_loglike[["k"]]
lambda_loglike <- info_loglike[["lambda"]]
print(paste("Best K_Denovo :", k_loglike))
print(paste("Best Lambda :", lambda_loglike))

```


### Best k_denovo and $\lambda$ (based on BIC)
```{r, echo=FALSE}

info_bic <- best_bic(data)
index_bic <- info_bic[["index"]]
k_bic <- info_bic[["k"]]
lambda_bic <- info_bic[["lambda"]]
print(paste("Best K_Denovo :", k_bic))
print(paste("Best Lambda :", lambda_bic))

```


### plot k over Likelihood grouped by $\lambda$
```{r, echo=FALSE}
plot_overall_loglike(data)
```

### plot k over BIC grouped by $\lambda$
```{r, echo=FALSE}
plot_overall_bic(data)
```

### plot signature shares over branches for best k grouped by lambda (log-likelihood)
```{r, echo=FALSE}
plot_alpha_loglike(data)
```

### plot signature shares over branches for best k grouped by lambda (BIC)
```{r, echo=FALSE}
plot_alpha_bic(data)
```

### plot inferred signature profiles
```{r, echo=FALSE}
plot_signatures(data)
```




